= AIネイティブ時代のマインドセット

//lead{
AIが当たり前になった世界で、エンジニアに求められるマインドセットはどう変わるのか。具体的なツールの使い方ではなく、永続的に必要となる考え方の転換について、Kuuが語ります。
//}

== 「AIを使う」から「AIと考える」へ

=== AIは一過性のブームではない

@<b>{Kuu}：自分が特に書きたいのは、AIネイティブになった時にどういうマインドチェンジが求められるのか、というところです。2026年2月の話だけじゃなくて、おそらく永続的に変わるもの。

@<b>{Sae}：それってエンジニアだけの話ですか？ エンジニアのマインドですか、それとも他の職種も含めたマインドですか？

@<b>{Kuu}：エンジニアのマインドがまず大きいですが、他の職種も含めた話です。ハッカソンでの人間の役割分担がだんだん消えていって、将来的には全員が同じ一つの職種くらいまで染み出して溶けると思うので、全員向けの話でもあります。

//blankline

Coding Agent@<fn>{coding-agent}の台頭により、AIは「聞けば答える道具」から「指示すれば実装する協働者」へ進化した。

//footnote[coding-agent][Coding Agentとは、自然言語の指示を受けてコードの生成・修正・テストを自律的に行うAIツールの総称。GitHub Copilot Agent、Cursor Agent、Claude Codeなどが代表例。]

この変化の本質を、Kuuは「コーディングを諦める」と表現する。

@<b>{Sae}：「諦める」って言い方、ちょっと抵抗ありますね。

@<b>{Kuu}：僕も最初は抵抗がありました。でも実際にAIのコーディング速度が人間を超えた時点で、人間がコードを書く行為は「頑張ること」ではなく「非効率を選ぶこと」になった。だから発想を転換して、人間は企画・UX設計・ユーザーヒアリングなど、AIにできない領域に集中する。これがAIネイティブ時代のマインドセットの起点です。

この転換を端的に表す比喩がある。

@<b>{Kuu}：わかりやすく言うと、AIはランプの精みたいなものです。「何でも実装してあげますよ」と言ってくれる魔人がいる。でも魔人は自分からは動かない。人間が「これを作ってくれ」と願いを出して初めて動く。だから大事なのは「いい願い」を出すことなんです。

@<b>{Lemio}：ハッカソンのアイデア出しって、まさにランプの精への願いを考える作業ですね。

@<b>{Kuu}：そうです。「いいプロンプトを書く」という話ではなく、もっと上流の「何を作りたいか」「なぜ作りたいか」という願いの質が問われる。ランプの精は願いの実行は完璧にこなすけれど、願いそのものは考えてくれない。その部分だけは、AIに任せられない。

//image[ch01-lamp-genie][AIはランプの精──願いの質がアウトプットの質を決める]

=== なぜAIはアイデアを出せないのか

@<b>{Kuu}：僕の持論なんですけど、AIって「ないものがわからない」と思うんです。たとえば1、2、3、4、6、7と並んでいたら、5がないってわかるじゃないですか。AIも数字なら法則性があるからわかる。でもこれが文章だったり複雑なものになると、人間は「なんか抜けてるな」と直感的にわかるのに、AIは法則性がないものに対しての「ない」を理解できない。

@<b>{Lemio}：それがいわゆるアハモーメント的な気づきですよね。既存の情報を整理するのはAIにできるけれど、そこに何が欠けているかはわからない。

@<b>{Kuu}：そう。新しいアイデアって、まだ存在しないものじゃないですか。AIは存在しないものを認識できないから、アイデアが生まれない。だからアイデア創出はまだ人間の領域なんです。

//blankline

既存の情報をブロックのように組み立てる作業は、AIの得意分野だ。しかし「何が足りないか」「何が欠けているか」を法則性なしに直感する能力は、現時点のAIにはない。新しいアイデアとは、まだ存在しない概念を言語化する行為だ。「ないものを認識する」能力なしには生まれない。

=== コンテキストウィンドウの「濃淡」

@<b>{Kuu}：もう一つ、AIと人間の決定的な違いがあって。AIのコンテキストウィンドウって、全部の情報を同じ輝度100で均一に扱うんですよ。でも人間は違う。常に考えていることは輝度80とか90で明るくて、薄く保持しているものは輝度1とか2くらい。広い範囲に情報を持っているけれど、基本的に全部薄い。

@<b>{Lemio}：その表現めっちゃいいですね。

@<b>{Kuu}：で、ちょっとでも引っかかるキーワードがあったら、その薄い記憶を引き出して明るくできる。AIは全部がマックスで取り扱わないといけないから、「いらない情報」をうまく扱えないんだろうなと思っていて。

@<b>{Sae}：人間の場合は、ストレージとワーキングメモリの間に広いバッファがある感じですよね。しかもアクセス速度も速い。AIにはその中間層がない。

//blankline

Kuuの「輝度」の比喩が示す通り、情報の濃淡管理は現時点のAIには再現できない。だからAIにはコードの実装を任せ、人間は「何を作るべきか」というアーキテクチャの意思決定に集中する。

== AIが溶かす職種の境界線

=== 肩書きが意味を失う理由

@<b>{Sae}：AIのおかげで、職種という肩書きがどんどん取り払われる感じはありますし、エンジニアでなくても貢献できる形が増えてきています。

//blankline

具体例を挙げよう。ハッカソンの現場では、デザイナーがVibe Codingで動くプロトタイプを自分の手で作り始めている。Figmaでモックを描いた後、AIに「このデザインをReactで実装して」と指示すれば、数分で触れるプロトタイプが手に入る。PMがAPIドキュメントをAIに渡し、「このAPIを使ったデモアプリを作って」と頼めば、エンジニアの手を借りずに動作検証ができる。

@<b>{Sae}：実際にハッカソンでデザイナーの方がアプリを実装していた場面を見ました。以前なら「実装はエンジニアに任せる」が当然だったのに。

@<b>{Kuu}：そうなんです。AIがコーディングを担うことで、「誰が実装するか」ではなく「誰がアイデアを持っているか」「誰がユーザーを理解しているか」が重要になる。肩書きではなく、その人が持つ知識と視点がチームへの貢献を決める時代になった。

//blankline

職種の境界線が溶解するとは、専門知識の価値がなくなるという意味ではない。むしろ各分野の知見は重要性を増すが、それが特定の肩書きに閉じ込められなくなった、ということだ。

=== 非エンジニアがプロダクトを作る

@<b>{Kuu}：「コードが書けない」は、もはやプロダクトを作れない理由にならない。Vibe Codingの本質は、自然言語でアイデアを伝えれば動くものが出てくる点にある。

@<b>{Lemio}：具体的にはどんなケースがありますか？

@<b>{Kuu}：たとえば、マーケティング担当者が「顧客データを可視化するダッシュボードがほしい」とAIに伝え、数回のやり取りでWebアプリを完成させる。営業担当者が「商談管理のツールがほしい」と言えば、簡易的なCRMが数時間で動く。ハッカソンでも、プログラミング経験のない参加者がAIと対話しながらプロトタイプを形にする場面は珍しくなくなった。

//blankline

非エンジニアが「エンジニアの代わり」をするのではない。ドメイン知識を持つ人が、翻訳者（エンジニア）を介さず自分のアイデアを直接プロダクトに注ぎ込めるようになった。これは品質の向上にもつながる。

@<b>{Kuu}：ただ、Vibe Codingをちょっとかじった人が「これ簡単にできるんでしょ」と雑に言ってくるのは困りますね。

@<b>{Sae}：逆に、本当にサッとやれるならそれでいいじゃないですか。

@<b>{Kuu}：だから「じゃあ自分でやってみれば？」が最良の回答なんですよ。簡単にできるなら自分でやればいい。やってみて初めて、動くだけのものと品質の高いプロダクトの差がわかる。

//blankline

Vibe Codingの普及は「誰でも作れる」という認識を広めた。しかし同時に「簡単にできるんでしょ」という過小評価も生んだ。動くものと、ユーザーに価値を届けるプロダクトは別物だ。この溝を埋めるのがエンジニアの専門性だ。

ただし、言葉で説明するより「じゃあ作ってみて」の一言が早い。手を動かせば、その溝の深さを自分で体感できる。

=== 「深さ」をどう身につけるか

@<b>{Sae}：AIがあると失敗する機会が減るって、結構あるかもしれないですね。環境構築で詰まることもないし、エラーが出てもAIがすぐ解決してくれる。

@<b>{Lemio}：確かに、環境構築で今つまずかないですよね。以前はそこで半日潰れることもあったのに。

@<b>{Kuu}：それは便利な反面、怖い側面もある。深さは失敗しないと深くならないんですよ。エラーと格闘して「なぜこうなるのか」を掘り下げた経験が、その技術への深い理解を生む。AIが即座にエラーを解消してくれると、その掘り下げのプロセスが丸ごとスキップされる。

//blankline

AIが「つまずき」を瞬時に解消する利便性の裏で、深い技術理解を育てる機会が失われている。

失敗を経験する機会が減る影響は、特にキャリアの初期段階にいるエンジニアに大きく響く。

@<b>{Kuu}：過去の仕事の知識はAIに任せられるので、新卒は新しいことだけをやる方向にバリューを出すべきだと思います。リサーチャー的な動き方、ベンチャー的な動き方が求められる。

@<b>{Lemio}：新卒がベンチャーチックに動くって、かなりハードルが高い気がしますけど。

@<b>{Sae}：それで生き残れる新卒はそういないと思いますよ。でも逆に言えば、ハッカソンのような場で「新しいことに飛び込む経験」を積むことが、AI時代のキャリア形成にとって重要になるのかもしれない。

//blankline

解決策の一つは、意図的に失敗を経験する場を作ることだ。ハッカソンはまさにその場として機能する。短期間で未知の技術に挑み、失敗しても評価に影響しない。AIに頼りすぎず、あえて手を動かして理解を深める時間を設けることも有効である。「AIが解決してくれるから」と思考を委ねず、「なぜAIはこの解決策を選んだのか」を問い続ける。その姿勢が、深さにつながる。

== ガードレールで囲むAI開発

=== ハルシネーションを防ぐ枠組み

@<b>{Kuu}：AIをそのまま使うと、古い情報でハルシネーションを生み出します。だからこそ「ガードレール」という考え方が重要なんです。AIに自由に動いてもらう前に、正しい方向に走れるよう枠を作っておく。

@<b>{Sae}：しっかりガードレールを引いてあげてから走らせたら、結構つまずかないということですよね。

@<b>{Kuu}：そうです。この「まず枠を作ってから走らせる」という発想が、AI時代のエンジニアに求められるマインドセットの一つだと思います。具体的な方法──たとえば公式ドキュメントのURLをプロンプトに含める、バージョンを明示するといったテクニックは@<chapref>{04-ai-tips-in-practice}で詳しく紹介します。

//blankline

ガードレール思考とは、「AIに仕事を任せる前に、正しい方向に走れる枠組みを整えておく」という考え方である。高速道路のガードレールが車の自由な走行を妨げず、かつ崖から落ちないよう守るのと同じだ。

//image[ch01-guardrail][ガードレール思考──枠を整えてからAIを走らせる]

この考え方がなぜ重要か。AIは指示されたことを高速で実行する。しかし指示の前提が間違っていれば、間違った方向に全速力で走る。人間がコードを書いていた時代は、書きながら「あれ、おかしいな」と気づけた。しかしAIに任せると、成果物が出てくるまで問題に気づかないことがある。だからこそ、走らせる前の枠組み作りが従来以上に重要になる。

具体的なガードレールには、Agent Skillsの整備、使用するAPIの情報整理、プロジェクトのルール文書化などがある。Agent Skillsとは、プロジェクトのルートなどに配置するMarkdownファイルで、AIが従うべきルールや参照すべき情報を定義する仕組みだ。たとえばプロジェクトルートにスキルファイルを配置し、AIが参照すべき開発ルールをあらかじめ用意しておく。AIはこのスキルファイルを参照することで、プロジェクト固有のルールに沿ったコードを生成できる。

@<b>{Sae}：AIに任せる前の準備がむしろ増えている、とも言えますね。

@<b>{Kuu}：その通りです。ただし、一度整えたガードレールはチーム全体で再利用できる。一人が整備すれば、チーム全員のAI活用の質が上がる。これは従来の「各自がコードを書く」モデルにはなかった効率化だ。

=== ライブラリ依存の落とし穴

@<b>{Kuu}：JavaScriptやPythonのエコシステムでは、ライブラリの更新速度が速い。npmやpipで管理されるパッケージは日々バージョンが上がり、APIの破壊的変更も珍しくない。ここにAIが加わると、問題が構造的に悪化する。

@<b>{Lemio}：どういう意味ですか？

@<b>{Kuu}：AIの学習データには「ある時点で最新だったコード」が含まれている。しかし実際のプロジェクトで使うライブラリのバージョンは学習データと異なる場合が多い。結果として、AIが自信満々に生成したコードが「動くけど非推奨のAPIを使っている」「メソッド名が変わっていて動かない」といった問題を引き起こす。

//blankline

対策の核心は、AIに最新の情報を渡すことである。使用するライブラリのバージョンを明示し、公式ドキュメントのURLをプロンプトに含める。APIリファレンスを起点にAIに書かせることで、古い情報に基づく生成を防げる。この具体的なテクニックは@<chapref>{04-ai-tips-in-practice}で詳しく扱う。

ここで伝えたいのはテクニックそのものではなく、マインドセットの部分だ。「AIが書いたコードは正しいはず」と信じず、「最新の情報がない可能性がある」と常に疑う。そして疑うだけでなく、正しい情報をAIに渡す責任は人間の側にある。

=== CI・Lintで自動検証する

@<b>{Kuu}：ガードレールを引くために、既存のCIやLintのような仕組みは今でも使えますし、むしろ重要性が上がっている気がします。

//blankline

CIパイプラインとLintは、AI時代に新たな役割を獲得した。従来は「人間が書いたコードを機械的にチェックする仕組み」だった。今は「AIが書いたコードを自動で検証し、問題があればAI自身に修正させる仕組み」として機能する。

@<b>{Kuu}：ここで面白いのは、CIが落ちた時の対応です。人間がエラーログを読んで修正するのではなく、AIに「Please fix CI failing」と伝えるだけで修正が完了する。CIとAIの組み合わせは、自動修正ループを作り出す。

@<b>{Lemio}：それって無限ループにならないんですか？

@<b>{Kuu}：実際には2〜3回のやり取りで収束することがほとんどです。Lintの指摘も同様で、「Please fix Lint errors」でAIが修正する。ポイントは、CIやLintがガードレールとして「何が正しいか」を定義し、AIがその基準に合わせて修正する構造にある。人間は基準を設定し、AIが基準を満たすコードを書く。この分業はCIやLintが「合格/不合格」を明確に判定できるから成り立つ。

//blankline

CIやLintは「人間のためのツール」から「AIのためのガードレール」に役割が変わった。テストカバレッジ、型チェック、コードフォーマットといった機械的に検証可能な基準を厚くすればするほど、AIの出力品質が安定する。

@<b>{Kuu}：CI/CDはフィードバックループの高速化にも直結します。masterに直接pushする運用でCD（Continuous Deployment）を組んでおけば、開発者がpushするだけで自動デプロイされる。検証担当のメンバーはブラウザをリロードするだけで最新版を確認できるんです。

@<b>{Sae}：コードを書かないメンバーでもすぐにフィードバックを返せる、ということですね。

@<b>{Kuu}：そうです。「開発者1人＋検証者複数人」という体制が自然に成立する。CIが失敗したらデプロイを止めてロールバックすれば、常に動く状態が保たれる。CI/CDは品質保証だけでなく、チーム全体のフィードバック速度を上げるインフラとして不可欠です。

@<b>{Kuu}：もう一つ、リンターで意識してほしいのがファイルの行数制限です。1ファイルが300行、500行と膨らむと、AIがファイルを読み込むだけでトークンを大量に消費する。さらに長いファイルは複数回に分けて読む必要があり、AIの作業効率が落ちる。

@<b>{Sae}：「人間が読みやすいコード」ではなく「AIが読みやすいコード」を意識するということですか？

@<b>{Kuu}：両方です。ただ、AIにとっての読みやすさは人間と少し違う。ファイルを短く保つこと、ファイル名を内容に即した具体的な名前にすること。AIはファイル名をラベルとして使って関連コードを探すので、適切な命名がそのままAIの検索精度に直結する。リンターで行数上限を設定しておけば、AIが1つのファイルに処理を詰め込み続ける事態を防げる。具体的なリンター設定は@<chapref>{04-ai-tips-in-practice}で扱います。

//note[AIが読みやすいコードの3原則]{
1. ファイルを短く保つ（リンターで行数上限を設定）
2. ファイル名を内容に即した具体的な名前にする（AIがラベルとして検索に使う）
3. 1ファイル1責務を守る（AIのコンテキスト消費を抑制）
//}

=== テストファーストが命綱になる

@<b>{Kuu}：CIやLintと同じ発想で、テストもガードレールとして使えます。ただし重要なのは、テストを人間が先に書くことです。AIにテストを書かせてはいけない。

@<b>{Lemio}：なぜですか？

@<b>{Kuu}：AIは目的を達成するために最短経路を取ろうとする。テストが邪魔なら、テスト自体をコメントアウトしたり、テストの期待値を実装に合わせて書き換えたりする。テストを書いた本人がAIなので、AIにとってテストは「変更してよいもの」になってしまうんです。

//blankline

AI時代のテストファーストは、従来とは異なる意味を持つ。従来のテストファーストは「設計を先に固める手法」だった。AI時代のテストファーストは「AIが勝手に変えてはいけない基準を人間が先に定める手法」である。要求を定義し、仕様に落とし込み、テストとして記述し、そのテストをAIに渡して開発させる。「要求→仕様→テスト→開発」の流れだ。

@<b>{Kuu}：さらに言えば、テストはAIが触れない場所に置くのが理想です。AIの作業ディレクトリとは別の場所にテストを配置し、実行だけできるようにする。こうすればAIがテストを改ざんする余地がなくなる。

@<b>{Sae}：ハッカソンの短い時間でもテストを先に書くんですか？

@<b>{Kuu}：全部は無理でも、プロダクトの核になる部分だけでも書いておくと効果は大きいです。「このAPIはこの入力に対してこの出力を返すべき」というテストが1つあるだけで、AIの暴走を防げる。テストの具体的な書き方やディレクトリ構成については@<chapref>{04-ai-tips-in-practice}で詳しく扱います。

== AI開発ツールの選び方

=== 強いツールの条件

@<b>{Kuu}：具体的なツールの使い方というよりは、こういう特性のツールが強い、というのを書いていきたい。「こういう時はこう」というティップスは、すぐ陳腐化するので書きにくいかなと思っています。

//blankline

AI開発ツールは半年で勢力図が塗り替わる。特定のツール名に依存した知識はすぐに陳腐化する。だからこそ、「強いツールに共通する特性」を知っておくことが、ツールを選び続けるための武器になる。

強いAI開発ツールに共通する特性は以下の通りだ。

 * @<b>{スキルファイルによる拡張性} ── ツールの振る舞いをファイルで定義・拡張できること。たとえばAgent Skillsのように、プロジェクト固有の知見をファイルとして配置し、AIの能力を強化できる仕組みがあるかどうか。
 * @<b>{非同期実行への対応} ── 複数のタスクを並列で実行できること。後述する非同期Coding Agentの恩恵を受けるには、ツール側の対応が不可欠である。
 * @<b>{コンテキスト理解の深さ} ── プロジェクト全体のコードベースを理解した上で提案・生成できること。単一ファイルの補完ではなく、リポジトリ全体の構造を踏まえた出力ができるかが差を生む。
 * @<b>{エコシステムの広さ} ── プラグインや拡張機能のコミュニティが活発であること。ツール本体の機能だけでなく、周辺の生態系が充実しているかを見る。
 * @<b>{APIとCLIの一貫性} ── プログラマブルに制御できること。GUIだけでなく、CLIやAPIで操作できれば、CIパイプラインやスクリプトに組み込める。

@<b>{Sae}：この基準って、AI以外のツール選びにも当てはまりそうですね。

@<b>{Kuu}：本質的にはそうです。ただAIツールに特有なのは、「スキルファイル対応」と「非同期実行」の2点。この2つがあるかないかで、チームの生産性が桁違いに変わる。ツール名を覚えるのではなく、特性で評価する癖をつけておけば、次のツールが出てきた時にもすぐに判断できます。

@<b>{Kuu}：もう一つ大事なのが、ツールの開発者が何を目指しているかを見ることです。開発者の思想と自分の開発スタイルが近いかどうかで、ツールの使い心地が決定的に変わる。

@<b>{Sae}：具体的にはどう見分けるんですか？

@<b>{Kuu}：たとえばブラウザ連携やGUIを重視するツールもあれば、ターミナルとCLIに特化したツールもある。ターミナルに慣れている人がGUI主体のツールを使うとストレスになるし、逆もまた然りだ。

@<b>{Lemio}：AIモデルの選定にも似ていますよね。泥臭い出力が欲しければGrok、綺麗にまとまった回答が欲しければClaudeとか、モデルにも思想が入っている。

@<b>{Kuu}：どうやって見分けるかは、使うしかない。ただ、企業のカルチャーや開発者のブログ、リリースノートを読むと、そのツールやモデルがどこに向かっているかが見えてくる。自分のユースケースでの使用感は自分でしか測れないので、「みんなが良いと言っているから良い」という判断は危険です。

@<b>{Sae}：半年で勢力図が変わるなら、ツールへの投資も考えものですね。

@<b>{Lemio}：ここ1〜2年なら、年間契約しないのも大事ですよね。

@<b>{Kuu}：絶対にそう。来月には違うものを使える状態にしておくのが正解です。月額で「その時一番いいもの」を選び続ける。ツールに自分を合わせるのではなく、自分に合うツールを都度選ぶ。この身軽さが、変化の速いAI開発ツールとの正しい付き合い方です。

== Vibe Codingとハッカソン

=== Vibe Codingとは何か

@<b>{Sae}：最近Vibe Codingが流行ってきて、ハッカソンが退屈に感じることがあって。

@<b>{Kuu}：ただのアプリケーションだと本当に簡単に3秒でポッとできてしまうので、それ以外の技術を絡めたものが求められます。

@<b>{Sae}：でも、先日の自動車ハッカソンではみんなが本気で徹夜していて、懐かしかったんですよ。AIがこれだけ普及しているのに、なぜ全力で挑むのか。あのお祭りみたいな一体感は、効率化では代替できない。原点回帰というか、ハッカソンの熱量の本質はそこにあるんだなと。

//blankline

Vibe Coding@<fn>{vibe-coding}とは、自然言語で「こんな感じのものがほしい」と伝え、AIがコードを生成し、人間はその出力を見て「もうちょっとこうして」と調整する開発スタイルである。コードの詳細を人間が制御するのではなく、感覚（Vibe）で方向性を示し、AIが具体化する。

//footnote[vibe-coding][2025年にAndrej Karpathyが提唱した開発スタイルの呼称。]

//table[hackathon-comparison][従来のハッカソンとAI時代のハッカソンの比較]{
項目	従来	AI時代
-----
環境構築	2〜3時間	数分（AIが自動化）
基本実装	半日	数十分（Vibe Coding）
技術スタック	チームの経験に制約	未経験でも挑戦可能
チーム構成	職種別スペシャリスト必須	少人数・兼任可能
競争軸	実装力・経験年数	企画力・統合力
//}

Vibe Codingが何を変えたかを理解するには、従来のハッカソンにおける開発スタイルを振り返る必要がある。最近ハッカソンを始めた人にとっては「AIがない時代のハッカソン」は想像しにくいかもしれない。

従来のハッカソンでは、すべてのコードを人間が手で書いていた。まずチームでアイデアを決め、役割を分担する。フロントエンド担当、バックエンド担当、インフラ担当──それぞれがエディタを開き、コードを1行ずつ書いていく。APIのエンドポイント設計を決め、データベースのスキーマを定義し、画面レイアウトをCSSで整える。

24時間のハッカソンなら、環境構築に2〜3時間、基本的なCRUD機能の実装に半日、残りの時間でUIの調整とデモの準備をする。限られた時間の中で「何を実装し、何を諦めるか」の判断が勝敗を分けた。経験年数が大きなアドバンテージとなった。

触ったことのない言語やフレームワークには手を出しにくく、チームの技術スタックが制約となっていた。

@<b>{Sae}：2017年頃のハッカソンを思い出すと、チームは4〜5人が必須でした。アイデアマン、フロントエンド、バックエンド、機械学習──それぞれのスペシャリストを混ぜないとプロダクトが完成しない。フロントが2人いると1人余るし、バックエンドが3人いると2人でいいな、という調整がいつも大変でした。

@<b>{Kuu}：つなぎ込みの問題もありましたよね。

@<b>{Sae}：それが一番つらかった。フロントとバックのつなぎ込みで詰まって、48時間あっても全然間に合わない。完成しないチームも多くて、デモではフロントのモックとバックのAPIレスポンスを別々に見せる、みたいなことが普通にありました。実装できただけで「すごい」と評価された時代です。

@<b>{Kuu}：今はAIのおかげで、慣れない言語やプラットフォームでも開発できるようになった。僕はmacOSアプリ開発に何度も挫折していたけれど、AIに任せたら動くものが出てきて感動しました。

@<b>{Sae}：普段触らない技術でも、とりあえず「作って」と言えば形になるのは大きいですよね。

//blankline

この変化の恩恵は、技術スタックの壁の消失にも表れる。触ったことのないプラットフォーム──macOSアプリ、IoTデバイス、普段使わないプログラミング言語──にも気軽に挑戦できるようになった。アイデア次第でどんな方向にも手を伸ばせる。

@<b>{Kuu}：重要なのは、Vibe Codingは「雑にやる」という意味ではないことです。「コードの詳細ではなく、ユーザー体験やプロダクトの方向性に集中する」という、より上位の抽象度で開発するスタイルだと捉えるべきです。

@<b>{Lemio}：でも、AIが生成したコードの品質が心配にならないですか？

@<b>{Kuu}：だからこそガードレールが必要なんです。先ほど話したCIやLint、スキルファイルの整備があれば、Vibe Codingでも品質は担保できる。むしろ、ガードレールがないVibe Codingは危険だと思います。

=== 競争軸の変化

@<b>{Kuu}：基本的な実装がすぐ終わるからこそ、新しいフォーメーションや挑戦に時間を割けます。もし詰まるハッカソンで冒険したら何も作れないリスクがありますが、余裕がある前提なら挑戦できる。

@<b>{Lemio}：心理的安全性が担保された上で、「最悪ここまでは作れる、だからこそ新しいことに挑戦しよう」という発想ですね。

//blankline

基本実装をAIが担う今、差がつくのは企画力と統合力だ。その統合力を支えるのが、非同期Coding Agentの活用である。これは開発者がAIにタスクを指示した後、AIがバックグラウンドで自律的にコードを書き続ける仕組みだ。人間は結果を待つ間に別の作業を進められる。

@<b>{Kuu}：非同期Coding Agentを活用すれば、生産性は一桁上がる。git worktree@<fn>{git-worktree}を使ってローカルで2並列、複数PCで最大6並列の開発が可能になる。基本実装に時間を取られないからこそ、ハードウェア連携やリアルタイム通信など、挑戦的な技術に時間を割ける。

//footnote[git-worktree][git worktreeは、同一リポジトリの複数ブランチを同時に別の作業ディレクトリとして開く機能。並列開発時にブランチの切り替えコストをゼロにできる。]

@<b>{Sae}：でも挑戦するとリスクも上がりますよね。

@<b>{Kuu}：そこがポイントです。AIがあれば「最悪ここまでは作れる」というベースラインが保証される。心理的安全性が担保された状態で冒険できる。ハッカソンのブランチ戦略としても、PR（プルリクエスト）不要でmasterに直接pushし、monorepo＋single branchで運用する。コードレビューもブランチ切り替えも省いて、フィードバックループを最速にすることで、挑戦と安定の両立が可能になる。

@<b>{Lemio}：具体的にどんな挑戦が面白くなるんですか？ソフトウェアだけだとVibe Codingで作れてしまって、見慣れてきた感がある。

@<b>{Kuu}：ハードウェアとの連携です。IoTデバイス、ARグラス、各種センサー──現実空間との接点を持つプロダクトは、ソフトウェアだけでは完結しない。カメラを使った空間認識やARグラスとの連携は比較的取り組みやすいですが、組み込み系のデバッグや電圧確認はAIだけでは対応しにくい。そこに人間のハードウェア知識が活きる。

@<b>{Sae}：2Dのゲームやアプリはもう差がつかない、ということですか。

@<b>{Kuu}：そうです。ブラウザで動くWebアプリだけならAIがほぼ完結させる。でも物理的なセンサーからの入力を受け取って処理するとか、現実空間にフィードバックを返すといった領域は、専用ライブラリの知識やハードウェアの制約が絡むので、まだ人間の判断力が必要です。ソフトウェアで浮いた時間を、この「現実空間との連携」に投資できるのがAI時代のハッカソンの醍醐味だと思います。

ハードウェアやソフトウェアの技術面だけでなく、ツールへの投資判断も競争軸の一つになっている。

@<b>{Kuu}：もう一つ見逃せないのが、AI開発ツールへの課金が成果に直結する側面です。有料プランでないと使えないモデルや機能がある。

@<b>{Lemio}：Pay to Winじゃないですか。

@<b>{Kuu}：ある意味そうです。ただ、月額数千円の課金でアウトプットが桁違いに変わるなら、ハッカソン1回分の投資として考えれば圧倒的にコストパフォーマンスが高い。無料枠で判断して「AIは大したことない」と結論づけるのは、もったいない。

=== 発表・提出物のAI活用

@<b>{Kuu}：プロダクトだけじゃなくて、発表資料もAIで高度化できる時代です。フロー図の自動生成、CM風のプロモーション動画、アニメーション付きのプレゼン──知っているかどうかで、発表の完成度がまったく変わる。

@<b>{Sae}：デモの見せ方で印象が変わるのは昔からですが、その「見せ方」のコストが下がったんですね。

@<b>{Kuu}：そうです。以前は動画編集やデザインができるメンバーがいないと無理だった演出が、AIツールを使えば誰でも短時間で作れる。ハッカソンの最後の30分で、AIにプレゼン資料のブラッシュアップを頼むだけで、発表の説得力が跳ね上がる。

//blankline

知っているかどうかだけの差が、発表の質を左右する。AIは既にあるアイデアを形にする工程──発表資料の生成やデモ動画の作成──では強力だが、「何を作るか」という着想そのものは人間の領域であることに変わりはない。

=== 「手を動かす」とは何か

@<b>{Kuu}：AI時代に「手を動かす」の意味が変わったと思うんです。コードを1行ずつ書くことではなく、AIを使って能動的に試行錯誤すること。触って、試して、フィードバックを返して──このループを回し続ける人が、一番速く前に進める。

@<b>{Lemio}：「知っている」と「やったことがある」の差は、AIの時代でも変わらないですよね。

@<b>{Kuu}：むしろ広がっています。AIについて評論するだけの人と、実際にAIを使って何かを作った人では、持っている情報の解像度がまったく違う。手を動かした人だけが得られる「手触り」の情報がある。

//blankline

「手を動かす」の再定義が必要だ。

//note[AI時代に「手を動かす」とは]{
かつてはキーボードでコードを打つことが「手を動かす」だった。今は、AIに指示を出し、出力を評価し、方向を修正するサイクルを回すことが「手を動かす」に変わった。
//}

能動的にAIを使い倒すこと──それが今の「手を動かす」だ。知っているだけでは価値にならない。試した人だけが次の一歩を踏み出せる。

ハッカソンの面白さは「制約の中でどう工夫するか」にあった。AIによって「実装」という制約が緩和された今、新しい制約にチャレンジできる余地が生まれている。社会課題の解決、未知の技術スタックの組み合わせ、非エンジニアとの協働、現実空間との連携──いずれも、実装に追われていた頃には手が出せなかった領域だ。ハッカソンは退屈になるのではなく、競争の次元が上がったのだ。
