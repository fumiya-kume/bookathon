= AI活用の実践テクニック──ハッカソンでも仕事でも使える知恵

//lead{
第1〜3章で語られた知見を横断し、ハッカソンでも日常業務でも活用できるAI活用の実践テクニックを3人でまとめます。具体的なツール名ではなく、考え方とアプローチに焦点を当てます。
//}

== AIに正しく仕事をさせるための前提条件を整える

=== 公式ドキュメントのURLをプロンプトに含めるだけで回答精度が劇的に上がる

@<b>{Kuu}：@<chapref>{01-ai-native-mindset}でガードレールの考え方を話しましたが、具体的な方法として一番効くのは、最新のAPIリファレンスのURLをプロンプトに含めることです。AIに読ませるだけで回答精度が全然違います。

@<b>{Lemio}：ドキュメントのURLを渡すだけでそんなに変わるんですか？

@<b>{Kuu}：変わります。特にJSやPythonはライブラリのバージョン更新が速いので、公式ドキュメントを起点にしないとAIが古いAPIで書いてきます。URLを渡す、バージョンを明示する、この2つだけでつまずきにくくなります。

//blankline

AIが生成するコードの品質は、与えるコンテキストの質に比例する。公式ドキュメントのURLをプロンプトに含める手法は、最も手軽でありながら効果が大きい。

具体的な手順は単純だ。使いたいライブラリやAPIの公式ドキュメントページのURLを、プロンプトの冒頭に「参考ドキュメント」として記載する。たとえば「以下の公式ドキュメントを参照してコードを書いてください」と一文添えるだけで、AIは学習データに頼らず、最新の仕様をもとにコードを生成する。

この習慣は、コンテキストの「鮮度管理」と呼べるものだ。情報には賞味期限がある。AIの学習データは数ヶ月前のスナップショットであり、日々更新されるライブラリのAPIとは乖離がある。公式ドキュメントのURLを渡す行為は、AIの持つ古い知識を最新の情報で上書きする作業にほかならない。

ここで大事なのは、AIの出力が期待と異なったときの受け止め方だ。「AIが間違えた」と嘆くのではなく、「自分のプロンプト設計に不足があった」と捉える。AIは与えられたコンテキストの範囲で最善を尽くしている。出力の品質が低いなら、入力の品質を疑う。この発想の転換が、AI活用の上達を加速させる。

=== 古いライブラリバージョンのコードをAIが自信満々に生成する問題

@<b>{Kuu}：AIは学習データの時点で最新だったバージョンのコードを自信満々に書いてきます。動くけれど非推奨のAPIを使っていたり、そもそもメソッド名が変わっていたりする。

@<b>{Lemio}：それ、動くだけに気づきにくいですよね。

@<b>{Kuu}：だからこそ、使うライブラリのバージョンとドキュメントをプロンプトで明示する習慣が大事です。

//blankline

この問題の厄介さは「動いてしまう」ことにある。エラーが出ればすぐに気づくが、非推奨APIで書かれたコードは正常に動作する。しかし将来のバージョンアップで突然壊れたり、セキュリティパッチが当たらなかったりする。技術的負債が静かに蓄積する。

典型的な例を挙げる。Pythonの@<code>{requests}ライブラリではセッション管理の推奨パターンが変わっているし、ReactではクラスコンポーネントからHooksへの移行が完了している。しかしAIは学習データの割合に引きずられ、古い書き方で生成することがある。

対策は3つだ。第一に、プロンプトでバージョンを明示する。「Python 3.12、React 19を使用」と書くだけで、AIは対応するAPIを選択しやすくなる。第二に、@<code>{package.json}や@<code>{requirements.txt}をプロンプトに含める。依存関係の全体像をAIに渡すことで、バージョン間の整合性が取れたコードが生成される。第三に、生成されたコードの@<code>{import}文を確認する。非推奨のモジュールからインポートしていないか、廃止されたパッケージを参照していないかをチェックする習慣をつける。

=== Agent Skillsを整備してAIの行動を仕組みで制御する

@<b>{Kuu}：プロンプトに毎回同じことを書くのは非効率です。Coding Agentには「Agent Skills」と呼ばれる仕組みがあって、プロジェクト固有のルールや慣習を事前に設定ファイルとして渡せる。これを整備しておくと、AIが毎回正しい前提で動いてくれます。

@<b>{Sae}：設定ファイルというのは、どのくらいの粒度で書くんですか？

@<b>{Kuu}：「このプロジェクトではTypeScriptを使う」「テストはVitestで書く」「コミットメッセージはConventional Commitsに従う」くらいの粒度です。プロジェクトのREADMEに書くような情報を、AIが読める形式で置いておくイメージですね。

//blankline

Agent Skillsの整備は、AIに対するオンボーディング資料の作成と同じだ。新しいメンバーがチームに入ったとき、プロジェクトの規約やコーディングスタイルを伝えるように、AIにもプロジェクト固有の文脈を渡す。

この仕組みの利点は、再現性にある。プロンプトに毎回「Prettierでフォーマットしてください」「エラーハンドリングはResult型を使ってください」と書く代わりに、設定ファイルに一度書いておけば、以降のすべてのやり取りでAIがその前提を踏まえて動く。チームメンバー全員が同じ設定ファイルを共有すれば、AIの出力品質がチーム全体で均一化される。

API情報の提供もAgent Skillsの重要な要素だ。プロジェクトで使っている外部APIのエンドポイント一覧、認証方式、レスポンスの型定義を設定ファイルに含めておくと、AIはAPIコールのコードを正確に生成できる。特にハッカソンでは、スポンサー企業が提供するAPIを初めて使うことが多い。APIドキュメントのURLと基本的な使い方をAgent Skillsに書いておくことで、チーム全員がAIを通じて素早くAPIを活用できる。

== 設計を言語化する──AIに伝わる設計書の作り方

=== 入力と出力を言葉にできればAIが間をつなぐ

@<b>{Lemio}：AIの時代に変わったのは、設計を言語化するスキルの重要性です。入力と出力を明確に言葉にできれば、その間の処理はAIが埋めてくれる。逆に言えば、言語化できない設計はAIにも伝わらない。

@<b>{Kuu}：「何を入れて、何が出てくるか」を定義するのが人間の仕事で、「どうやって変換するか」はAIの仕事になった、ということですよね。

@<b>{Lemio}：そうです。「この画面にユーザーが名前を入力すると、パーソナライズされた挨拶が表示される」──この一文があれば、AIはフォーム、バリデーション、表示ロジックまで一気に書ける。設計を言語化する力が、そのままAIの活用力になります。

//blankline

「設計を言語化する」とは、頭の中にある曖昧なイメージを、AIが解釈できる精度まで具体化する行為だ。これはプログラミングスキルとは別の能力である。コードが書けなくても、「入力はCSVファイル、出力は月別売上のグラフ、グラフはPNGで出力」と言語化できれば、AIはそのとおりに実装する。

このパラダイムシフトは、ハッカソンの戦い方を根本から変える。従来は「どう実装するか」に時間の大半を費やしていたが、今は「何を作るか」「どんな入出力を持つか」の設計に集中できる。設計さえ明確なら、AIが実装を担当する。

実践的なアプローチとして、機能ごとに「入力→処理→出力」の三行を書く方法がある。たとえば「入力：ユーザーの現在地（GPS座標）、処理：半径1km以内のレストランを検索してレビュースコア順にソート、出力：レストラン名・距離・スコアのリスト」と書く。この三行だけで、AIはAPIコール、ソートロジック、データ構造の設計まで一貫したコードを生成できる。

=== 非同期Coding Agentで並列開発を実現する

@<b>{Kuu}：Coding Agentの最大の利点は、非同期で動かせることです。人間が一つのタスクに集中している間に、別のタスクをAIに並列で進めてもらう。これはハッカソンでの時間効率を劇的に上げます。

@<b>{Sae}：具体的にはどうやって並列に動かすんですか？

@<b>{Kuu}：git worktreeを使います。一つのリポジトリから複数の作業ディレクトリを作って、それぞれに別のCoding Agentを割り当てる。Agent Aにはフロントエンドを、Agent Bにはバックエンドを、自分はインフラの設定をやる、という具合です。

//blankline

非同期Coding Agentの活用は、一人の開発者が複数人分の作業を同時進行させる手法だ。従来の開発では、一人が同時に着手できるタスクは実質一つだった。コンテキストスイッチのコストが高く、複数の作業を切り替えながら進めると効率が落ちる。しかしCoding Agentを並列で動かせば、人間はディレクションに徹しながら、複数のタスクを同時に前進させられる。

git worktreeは、一つのリポジトリから複数の作業ツリーを作成するGitの機能だ。通常のブランチ切り替えと異なり、物理的に別のディレクトリとして存在するため、それぞれのディレクトリで独立してCoding Agentを起動できる。メインのworktreeでは自分がUI設計を進め、別のworktreeではAgent AがAPI実装を進め、さらに別のworktreeではAgent Bがテストコードを書く──こうした並列作業が可能になる。

ハッカソンでは時間が限られているからこそ、この手法の効果は絶大だ。3人チームで6時間のハッカソンに参加する場合、各メンバーが2〜3のCoding Agentを並列で動かせば、実質的な作業量は数倍に膨らむ。ただし、並列化の前提として、タスクの分割と依存関係の整理が不可欠だ。依存関係が複雑なタスクを並列で進めるとコンフリクトが頻発し、かえって時間を浪費する。

=== master直push戦略──ハッカソンではブランチ運用を捨てる

@<b>{Kuu}：ハッカソンでは、あえてmasterブランチに直接pushする戦略を取ることがあります。通常の開発ではブランチを切ってプルリクエストを出すのが常識ですが、2〜3日の短期決戦ではそのオーバーヘッドが致命的です。

@<b>{Lemio}：コンフリクトの解消に時間を取られるリスクはないですか？

@<b>{Kuu}：あります。だからこそ、タスクの分割が重要です。フロントエンドとバックエンドで明確にディレクトリを分けたり、ファイルの担当を決めたりして、物理的にコンフリクトが起きにくい構造を先に作る。それでもコンフリクトが起きたときは、AIに「Please fix conflict」と指示すれば、大半の場合は自動で解決してくれます。

//blankline

通常の開発プロセスでは、コードレビューとブランチ管理が品質の担保に不可欠だ。しかしハッカソンという時間制約の下では、プロセスの厳密さよりもアウトプットの速度が優先される。

master直push戦略の前提条件は三つある。第一に、チームメンバー全員が担当領域を明確に分割していること。第二に、CIパイプラインが設定されており、pushのたびにビルドとテストが自動実行されること。第三に、コンフリクト発生時にAIで即座に解決する体制が整っていること。

CIが失敗した場合のプロンプトも定型化しておくとよい。「CIが失敗しています。以下のエラーログを確認して修正してください」──これだけでCoding Agentはエラーを解析し、修正コミットを生成する。「Please fix CI failing」というシンプルな指示が、ハッカソンにおけるCI修復の定型パターンになる。

この戦略はあくまでハッカソンや短期プロトタイピングに限定した手法であり、長期運用のプロダクトには従来のブランチ運用を推奨する。

== AIを学習パートナーとして使い倒す

=== 理解できるまで何度でも聞き直す──AIは嫌な顔をしない最強の家庭教師

@<b>{Lemio}：わかるまで聞けばいいんです。「わからない部分をもう一度説明してください」と何度でも聞く。そのやり方をレクチャーするのが、ググり方を教えるのと同じ感覚ですね。

@<b>{Kuu}：やり方さえわかれば、自走できますしね。

//blankline

AIを学習パートナーとして活用する最大の利点は、「何度でも同じことを聞ける」ことだ。人間の先生やメンターに同じ質問を繰り返すのは心理的なハードルがある。しかしAIは何度聞いても嫌な顔をしない。これは冗談ではなく、学習効率に直結する本質的な特性だ。

効果的な聞き方にはコツがある。「わかりません」とだけ伝えるのではなく、「ここまでは理解できたが、ここから先がわからない」と境界を示す。AIは理解の境界線を起点に、より噛み砕いた説明を返してくれる。

たとえば「Dockerの仕組みがわかりません」よりも、「コンテナが仮想マシンと違うことは理解したが、イメージとコンテナの関係がわからない」と伝えた方が、的確な回答が得られる。この「わかる境界」を伝えるスキルは、AI活用だけでなく、人間同士のコミュニケーションでも応用が利く。

この手法をチームに広めることは、かつて「ググり方を教える」のと同じ意味を持つ。検索エンジンの登場時、「何をどう検索するか」を知っている人と知らない人で情報アクセスの格差が生まれた。AIの時代も同様で、「AIにどう聞くか」を知っている人と知らない人で学習速度の格差が生まれる。聞き方のスキルを共有すること自体が、チームの底上げになる。

=== 未知の概念を「絵を見せて聞く」ように学ぶ──わからないことがわかれば深掘りできる

@<b>{Lemio}：昔テレビで見たんですが、アイヌの方にアイヌ語を教えてもらうとき、ぐちゃぐちゃの絵を描いて見せて、相手の反応から語彙を学んでいく方法がありました。わからないことさえわかっていれば、知識を広げられます。AIも同じように使えばいいんです。

@<b>{Kuu}：自分がわからないことさえわかっていれば、わかっている部分とわからない部分の境界を伝えて、わからない部分だけを深掘りしていけば全体が見えてきます。

//blankline

未知の概念に向き合うとき、最初の壁は「何がわからないかがわからない」状態だ。この壁を越える方法として、AIに断片的な情報を投げて反応を見るアプローチがある。

たとえば、新しいフレームワークの概念を学びたいとき、自分が知っている類似概念をAIに伝える。「Reactのstateに似たものがSvelteにもあると思うが、何と呼ぶのか」と聞けば、AIは「Svelteではリアクティブ変数と呼び、$: という構文で宣言する」と教えてくれる。既知の概念を足がかりに、未知の領域を探索する手法だ。

この学び方の本質は、「自分が何を知らないかを知る」ことから始まる点にある。ソクラテスの「無知の知」と同じ原理だ。自分の知識の境界線を認識し、その境界を少しずつ外側に広げていく。AIは、その境界線の拡張を手助けする最適なパートナーとなる。

ハッカソンにおけるこの手法の価値は大きい。限られた時間の中で、初めて触る技術スタックを学ばなければならない場面は多い。「何がわからないかを整理して、AIに段階的に聞く」というアプローチを身につけておけば、新技術のキャッチアップ速度が格段に上がる。

=== 音声AIで曖昧な検索をする──オノマトペや身振りで伝える新しい検索体験

@<b>{Kuu}：テキスト検索だとテキストに言語化しなければなりませんが、音声なら擬音語やオノマトペを使って、ふわっとした形から絞り込んでいくことができます。

@<b>{Lemio}：昔見たYouTubeの動画で、タイトルが全然わからなくても、「こういう感じのやつ」と探していったら出てきたりするんですよ。

//blankline

テキスト検索には構造的な限界がある。検索したいものの正確な名前や用語を知らなければ、検索クエリを組み立てられない。しかし音声AIを使えば、言語化が不完全な状態でも検索が成立する。

たとえば、UIのアニメーションパターンを探しているとき、「要素がふわっと現れて、スッと消える感じのやつ」と音声で伝えれば、AIは「フェードイン・フェードアウトのアニメーション」を提案してくれる。テキストで「CSS アニメーション フェード」と検索するには、まず「フェード」という用語を知っている必要がある。音声なら、オノマトペで伝えるだけでよい。

この手法は、デザインの領域で特に効果を発揮する。「なんかこう、カードがペラッとめくれる感じのトランジション」「ボタンを押したときにポヨンと跳ねるアニメーション」──テキスト検索では絶対にたどり着けない表現でも、音声AIは意図を汲み取って適切な技術用語やライブラリに変換してくれる。

ハッカソンの文脈では、デザイナーとエンジニアの間のコミュニケーションにもこの手法が使える。デザイナーが「ここ、もうちょっとシュッとした感じにしたい」と言ったとき、その曖昧な要望をAIが「余白を増やしてフォントウェイトを細くする」という具体的な実装に変換する。曖昧さを許容する検索は、チーム内の意思疎通の潤滑油にもなる。

===[column] 「なんかこう、ぐにゃっとしたやつ」で検索できる時代

従来の検索は「正確なキーワードを知っている人」が有利だった。CSSの@<code>{border-radius}を知らなければ「角丸」にたどり着けないし、@<code>{box-shadow}を知らなければ「影をつける方法」を検索できなかった。しかしAIの登場で、「なんかこう、角がまるっとしてて、ちょっと浮いてる感じのカード」と言えば、@<code>{border-radius}と@<code>{box-shadow}の両方を含むコードが返ってくる。

面白い事例を紹介する。ある開発者が「データがドバーッと流れてくる感じの画面」と音声で伝えたところ、AIはリアルタイムストリーミングのダッシュボードUIを提案した。別の開発者が「グラフがニョキニョキ生えてくるアニメーション」と伝えたところ、D3.jsのアニメーション付き棒グラフのコードが返ってきた。正確な技術用語を知らなくても、感覚的な表現でAIが意図を読み取る時代がすでに来ている。

===[/column]
